[TOC]

# 一，Python

## 1，python基础

### 基础

#### 1.1，new 和 init 的区别

#### 1.2，生成器和迭代器

#### 1.3，闭包的概念，装饰器

#### 1.4，range 和 xrange的区别

### 重点

#### 1.1，GIL锁

#### 1.2，python垃圾回收机制

#### 1.3，进程，线程，协程；多线程与多进程区别。

```
进程：
1、操作系统进行资源分配和调度的基本单位，多个进程之间相互独立
2、稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制

线程：
1、CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源
2、如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃
```

### 其他

#### 1.1，什么是猴子补丁

在程序运行期间动态的修改一个函数，类或模块。

#### 1.2，python自省

运行时能够获得对象的类型。比如：**type()、dir()、getattr()、hasattr()、isinstance()**

#### 1.3，提高python运行效率的方法

```
1、使用生成器，因为可以节约大量内存
2、循环代码优化，避免过多重复代码的执行
3、核心模块用Cython  PyPy等，提高效率
4、多进程、多线程、协程
5、多个if elif条件判断，把最可能先发生的条件放到前面写，可以减少程序判断次数，提高效率
```

## 2.web知识

#### 2.1，Web应用的本质

```
1. 浏览器发送一个HTTP请求；
2. 服务器收到请求，生成一个HTML文档；
3. 服务器把HTML文档作为HTTP响应的Body发送给浏览器；
4. 浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。
```

#### 2.2，cookie和session的区别

```
1，session 保存在服务器端，cookie 保存在客户端（浏览器），所以cookie安全性比session差，但性能更高。

2、session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效。服务端存储Session时，键与Cookie中的sessionid相同，值是开发人员设置的键值对信息，进行了base64编码，过期时间由开发人员设置。
```

#### 2.3，同源策略

需要同时满足以下三点要求： 1.协议相同  2.域名相同  3.端口相同 。



## 3.Django

#### 3.1，ORM

```
ORM，全拼Object-Relation Mapping，意为对象-关系映射。实现了数据模型与数据库的解耦，通过简单的配置就可以轻松更换数据库，而不需要修改代码只需要面向对象编程,orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句,所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite....，如果数据库迁移，只需要更换Django的数据库引擎即可。
```

## 4.Flask

## 5, 其他

#### 





# 二，MySQL

## 基础

#### 1，数据库的三范式

```
第一范式（1NF）
字段具有原子性,不可再分。(所有关系型数据库系统都满足第一范式数据库表中的字段都是单一属性的，不可再分)

第二范式（2NF）
要满足第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以被唯一地区分。通常需要为表加上一个列，以存储各个实例的唯一标识。这个唯一属性列被称为主关键字或主键。

第三范式（3NF）
满足第三范式（3NF）必须先满足第二范式（2NF）。第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。
第三范式具有如下特征：
  - 每一列只有一个值 ；
  - 每一行都能区分；
  - 每一个表都不包含其他表已经包含的非主关键字信息。
```

#### 2.MqSQL中 in 和 exists 区别

in 语句是把外表和内表作hash 连接；（MySQL5.5 会改写为exists语句，MySQL5.6中，会将独立in子查询改写为join查询）

exists 语句是对外表作loop循环，每次loop循环再对内表进行查询；所以外表需全表扫描，当外表非常大时，性能会很差。

```
1.如果查询的两个表大小相当，那么用in和exists差别不大。
2.如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。
```



## 重点

#### 1，锁的划分

```
锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。加锁开销从大到小，并发能力也是从大到小
InnoDB锁类型：读锁，写锁、意向锁、MDL锁。
InnoDB行锁种类：
  - 单个行记录上的锁（record lock）
  - 间隙锁（GAP lock）；
  - 记录锁和间隙锁的组合（next-key-lock），锁定一个范围，包含记录本身。
  注：普通索引默认的就是next-key lock模式。
```

**相关知识点：**

```
1.innodb对于行的查询使用next-key lock
2.当查询的索引含有唯一属性时，将next-key-lock降级为record key
3.RR隔离级别下，为了避免幻读现象，引入GAP lock。
4.Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，导致幻读问题的产生。
  - 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） 
	A. 将事务隔离级别设置为RC 
	B. 将参数innodb_locks_unsafe_for_binlog设置为1
```

#### 2，InnoDB引擎的行锁是怎么实现的？

InnoDB 行锁是**通过给索引上的索引项加锁**来实现的，这一点 MySQL 与 Oracle 不同，Oracle是通过在数据块中对相应数据行加锁来实现的。

InnoDB 这种行锁实现特点意味着：只有**通过索引条件检索数据，InnoDB 才使用行级锁，否则将使用表锁！**

#### 3，数据库什么情况下会产生死锁？怎么解决？

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象

**常见的死锁解决办法：**

```
1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
2、对于并发修改同一个表的多条记录，也需要以相同顺序访问数据行；（因为InnoDB每访问一行，就会    将其锁住，直到修改完所有行）
3、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
4、对于非常容易产生死锁的业务部分，可尝试使用升级锁粒度，通过表级锁定来减少死锁产生的概率；
```

#### 4，乐观锁，悲观锁，各自使用场景

为了确保多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

```
1.悲观锁：
假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
2.乐观锁：
假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：一般会使用版本号机制或CAS算法实现。

3.两种锁的使用场景
乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。
但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
```

#### 5，事务的四大特性

```
原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部回滚；
一致性：执行事务前后，数据状态保持一致。
隔离性：并发访问数据库时，一个事务不被其他事务所干扰，防止交叉执行导致数据不一致；
持久性：事务提交之后，对数据的改变是永久的，即使系统故障也不会丢失。
```

#### 6，数据库的事务隔离级别

```
1.读未提交(RU)：在一个事务中，可以读取到其他事务未提交的数据变化。
2.读已提交(RC)：在一个事务中，可以读取到其他事务已经提交的数据变化。
3.可重复读(RR)：MySQL默认；在一个事务开始到结束前，多次读取同样的目标数据，不会发生变化。避免了脏读、不可重复读、幻读现象的发生。
4.串行：在每个读的数据行上加表级共享锁，每次写数据时加表级排他锁。并发能力下降，大量超时和锁竞争会发生。
```

#### 7，MySQL的复制原理以及流程

复制过程中工作的线程：主服务器有一个工作线程I/O dump thread，从服务器有两个工作线程 (I/O thread 和 SQL thread)。

**主要复制过程如下：**

```
1.主库把接收的SQL请求记录到自己的binlog文件中；
2.从库的 I/O thread 去请求主库（主库通过IO dump thread 给从库IO thread传送binlog日志），将得到的binlog日志写入自己的Relay log(中继日志)文件中；
3.在从库上重做应用中继日志中的SQL语句，应用到自己的数据库上。
```

#### 8，Innodb的索引实现，为什么用B+树，B树和B+树的区别，各自优势

**为什么用B+树 而不是用B树**

```
1.B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
2.B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；
3.B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
4.B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。
5.增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率
```

**B树和B+树的区别：**

```
B-Tree：键和值存放在内部节点和叶子节点，叶子节点间各自独立。
B+Tree：仅叶子节点存储键值数据，非叶子节点只存储键，叶子节点间通过双向链表连接。
```

**B树和B+树各自的优势**

```
- B树
B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。
- B+树
由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间
```

## 进阶

#### 1，MySQL存储引擎MyISAM与InnoDB区别

```
事务支持：InnoDB支持事务，MyISAM不支持事务
锁：InnoDB 可支持行级锁，MyISAM 只支持表机锁，并发能力不如InnoDB
MVVC：InnoDB 支持 MVVC，而 MyISAM 不支持
外键：InnoDB 支持外键，而MyISAM 不支持
全文索引：InnoDB 不支持全文索引，而 MyISAM 支持
表主键：MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址；如果没有设定主键或者非空唯一索引，就会自动生成一个 6 字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。

索引：
索引存储方式不同：MyISAM使用前缀压缩技术是索引更小；InnoDB 则按照原数据格式进行存储。
索引方式不同：MyISAM索引通过数据的物理地址引用被索引的行；InnoDB根据主键引用被索引的行。
  - MyISAM：索引保存的是数据的物理地址；
  - InnoDB：索引保存真实的数据，（主索引保存完整行，普通索引保存索引列和主键值）
```

#### 2，InnoDB引擎的4大特性

```
1.插入缓冲（insert buffer)
2.二次写(double write)
3.自适应哈希索引(ahi)
4.预读(read ahead)
```

#### 3，索引的优缺点

```
- 优点：
1.加快检索速度，减少了服务器需要扫描的数据量。
2.帮助服务器避免排序和临时表。
3.将随机I/O变为顺序I/O

- 缺点：
1.创建索引和维护索引要耗费时间，增、删、改时，索引也要动态更新，会降低增/改/删的执行效率；
2.索引需要占物理空间
```

#### 4，索引设计的原则

```
1.适合索引的列：where子句中的列，连接子句on指定的列，或排序分组列。
2.使用选择性高(基数大）的列创建索引；
3.为经常查询使用的列创建索引；
4.使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间
5.不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
6.创建复合索引需遵循最左前缀原则。
```

#### 5，什么是聚簇索引

聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据。

```
innodb中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。
其他索引都称为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值
```

#### 6，binlog 和 redo log 的区别

binlog：二进制日志文件 ，redo log：重做日志文件(InnoDB)

```
1.记录的内容不同
  - binlog 是逻辑日志，记录所有数据的改变信息
  - redo log 是物理日志，记录所有InnoDB表数据的变化
2.记录内容的时间不同
  - binlog 记录commit完毕之后的 DML和DDL SQL语句
  - redo log 记录事务发起，数据修改之后的值，无论事务是否提交
3.写入文件的方式不同
  - binlog 不是循环使用，在写满或实例重启之后，会生成新的binlog文件
  - redo log 顺序写，循环写，最后一个文件写满后，会重新写第一个文件。写满日志文件切换时，会	触发脏页的刷新。
4.作用不用
  - binlog 可作为恢复数据使用，主从复制搭建。
  - redo log 作为故障宕机后的数据恢复使用，保证数据完整性。
```



# 三，Redis

## 基础

#### 1.为什么说redis是单线程模型？单线程有什么好处？

单线程模型指的是：一个线程处理所有网络请求，即执行redis命令的模块是单线程的；其他模块仍用了多个线程。

好处：1.不需要考虑并发安全性； 2.省去了很多上下文切换线程的时间

#### 2.redis分布式锁的实现

## 进阶

#### 1.redis扩容机制（渐进式单线程扩容）



# 四，网络

#### 1, 各种网络协议

- HTTP 超文本传输协议 / HTTPS 超文本传输安全协议  (应用层)
- FTP 文件传输协议  (应用层)
- SMTP 简单邮件传输协议  (应用层)
- DNS  (应用层)
- TCP 传输控制协议 / UDP 用户数据报协议  (传输层)
- IP  (网络层)

#### 2, TCP三次握手

#### 3, 介绍HTTPS协议，SSL协议，SSL建立连接的过程。  

**HTTPS：**

```
HTTP + 加密 + 认证 + 完整性保护 = HTTPS
HTTPS 就是身披SSL协议外壳的HTTP，只是 HTTP 通信接口部分用SSL 和 TLS 协议替代。
通常，HTTP直接和TCP进行通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。
HTTPS 采用混合加密机制：
- 使用公开密钥加密方式交换共享密钥加密的密钥
- 使用共享密钥加密方式进行之后的通信建立，交换报文
```

**HTTP的缺点：**

```
1.通信使用明文，内容可能会被窃听。       解决方案：SSL加密
2.不验证通信方的身份，有可能遭遇伪装。    解决方案：SSL证书
3.无法证明报文的完整性，有可能已遭篡改    解决方案：SSL完整性保护
（ps：其他未加密的协议中也会存在这类问题）
```

**SSL（安全套接层）：**

```
1.SSL提供：加密，认证，完整性保护
- 将HTTP通信线路进行加密。
- 提供证书认证手段，用于确定通信方。
- 提供报文完整性保护。

2.SSL采用 公开密钥加密（公私钥）的加密处理方式
```



# 五，Linux

#### 1.linux常用命令

```
ls  pwd  cd  vi  rm  mkdir  tree  cp  mv  cat  more  grep  shutdown 

重定向命令:
>  : 表示输出，会覆盖文件原有的内容
>> : 表示追加，会将内容追加到已有文件的末尾
```



# 六，设计模式

