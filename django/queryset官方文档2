### 不返回查询的方法(QuerySet methods that do not return QuerySets)

下面所列的 QuerySet 方法作用于 QuerySet，却并不返回 other than a QuerySet。

这些方法并不使用缓存(请查看 缓存与查询(Caching and QuerySets))。所以它们在运行时是立即读取数据库的。

**get(\**kwargs)**

返回与所给的筛选条件相匹配的对象，筛选条件在 字段筛选条件(Field lookups) 一节中有详细介绍。

在使用 get() 时，如果符合筛选条件的对象超过一个，就会抛出 MultipleObjectsReturned 异常。MultipleObjectsReturned 是 model 类的一个属性。

在使用 get() 时，如果没有找到符合筛选条件的对象，就会抛出 DoesNotExist 异常。这个异常也是 model 对象的一个属性。例如：

```
`Entry.objects.get(``id``=``'foo'``) ``# raises Entry.DoesNotExist`

```

DoesNotExist 异常继承自 django.core.exceptions.ObjectDoesNotExist，所以你可以直接截获 DoesNotExist 异常。例如：

```
`from` `django.core.exceptions ``import` `ObjectDoesNotExist``try``:``    ``e ``=` `Entry.objects.get(``id``=``3``)``    ``b ``=` `Blog.objects.get(``id``=``1``)``except` `ObjectDoesNotExist:``    ``print``(``"Either the entry or blog doesn't exist."``)`

```

**create(\**kwargs)**

创建对象并同时保存对象的快捷方法：

```
`p ``=` `Person.objects.create(first_name``=``"Bruce"``, last_name``=``"Springsteen"``)`

```

和

```
`p ``=` `Person(first_name``=``"Bruce"``, last_name``=``"Springsteen"``)``p.save(force_insert``=``True``)`

```

是相同的。

force_insert 参数在别处有详细介绍，它表示把当前 model 当成一个新对象来创建。一般情况下，你不必担心这一点，但是如果你的 model 的主键是你手动指定的，而且它的值已经在数据库中存在，那么调用 create() 就会失败，并抛出 IntegrityError。这是因为主键值必须是唯一的。所以当你手动指定主键时，记得要做好处理异常的准备。

**get_or_create(defaults=None,\**kwargs)**

这是一个方便实际应用的方法，它根据所给的筛选条件查询对象，如果对象不存在就创建一个新对象。

它返回的是一个 (object, created) 元组，其中的 object 是所读取或是创建的对象，而 created 则是一个布尔值，它表示前面提到的 object 是否是新创建的。

这意味着它可以有效地减少代码，并且对编写数据导入脚本非常有用。例如：

```
`try``:``    ``obj ``=` `Person.objects.get(first_name``=``'John'``, last_name``=``'Lennon'``)``except` `Person.DoesNotExist:``    ``obj ``=` `Person(first_name``=``'John'``, last_name``=``'Lennon'``, birthday``=``date(``1940``, ``10``, ``9``))``    ``obj.save()`

```

上面的代码会随着 model 中字段数量的激增而变得愈发庸肿。接下来用 get_or_create() 重写：

```
`obj, created ``=` `Person.objects.get_or_create(first_name``=``'John'``, last_name``=``'Lennon'``,``                  ``defaults``=``{``'birthday'``: date(``1940``, ``10``, ``9``)})`

```

在这里要注意 defaults 是一个字典，它仅适用于创建对象时为字段赋值，而并不适用于查找已存在的对象。 get_or_create() 所接收的关键字参数都会在调用 get() 时被使用，有一个参数例外，就是 defaults。在使用get_or_create() 时如果找到了对象，就会返回这个对象和 False。如果没有找到，就会实例化一个新对象，并将其保存；同时返回这个新对象和 True。创建新对象的步骤大致如下：

```
`params ``=` `dict``([(k, v) ``for` `k, v ``in` `kwargs.items() ``if` `'__'` `not` `in` `k])``params.update(defaults)``obj ``=` `self``.model(``*``*``params)``obj.save()`

```

用自然语言描述：从非 'defaults' 关键字参数中排除含有双下划线的参数（因为双下划线表示非精确查询），然后再添加 defaults 字典的内容，如果键名与已有的关键字参数重复，就以 defaults 中的内容为准, 然后将整理后的关键字参数传递给 model 类。当然，这只是算法的简化描述，实际上对很多细节没有提及，比如对异常和边界条件的处理。如果你对此感兴趣，不妨看一下原代码。

如果你的 model 恰巧有一个字段，名称正是 defaults，而且你想在 get_or_create() 中用它做为精确查询的条件, 就得使用 'defaults__exact' (之前提过 defaults 只能在创建时对对象赋值，而不能进行查询)，象下面这样：

```
`Foo.objects.get_or_create(defaults__exact``=``'bar'``, defaults``=``{``'defaults'``: ``'baz'``})`

```

如果你手动指定了主键，那么使用 get_or_create() 方法时也会象 create() 一样，抛出类似的异常。当你手动指定了主键，若主键值已经在数据库中存在，就会抛出一个 IntegrityError 异常。

最后提一下在 Django 视图(views)中使用 get_or_create() 时要注意的一点。如上所说，对于在脚本中分析数据和添加新数据而言，get_or_create() 是非常有用的。但是如果你是在视图中使用 get_or_create() ，那么就要格外留意，要确认是在 POST 请求中使用，除非你有很必要和很充分的理由才不这么做。而在 GET 请求中使用的话，不会对数据产生任何作用。而使用 POST 的话，每个发往页面的请求都会对数据有一定的副作用。

**Note**

通过多对多关系使用时要注意：

```
`class` `Chapter(models.Model):``    ``title ``=` `models.CharField(max_length``=``255``, unique``=``True``)` `class` `Book(models.Model):``    ``title ``=` `models.CharField(max_length``=``256``)``    ``chapters ``=` `models.ManyToManyField(Chapter)`

```

运行：

```
`>>> book ``=` `Book.objects.create(title``=``"Ulysses"``)``>>> book.chapters.get_or_create(title``=``"Telemachus"``)``(<Chapter: Telemachus>, ``True``)``>>> book.chapters.get_or_create(title``=``"Telemachus"``)``(<Chapter: Telemachus>, ``False``)``>>> Chapter.objects.create(title``=``"Chapter 1"``)``<Chapter: Chapter ``1``>``>>> book.chapters.get_or_create(title``=``"Chapter 1"``)``# Raises IntegrityError`

```

不和book相关联的Chapter就不会被查找到了。

**update_or_create(defaults=None, \**kwargs)**

与上面类似

```
`try``:``    ``obj ``=` `Person.objects.get(first_name``=``'John'``, last_name``=``'Lennon'``)``    ``for` `key, value ``in` `updated_values.iteritems():``        ``setattr``(obj, key, value)``    ``obj.save()``except` `Person.DoesNotExist:``    ``updated_values.update({``'first_name'``: ``'John'``, ``'last_name'``: ``'Lennon'``})``    ``obj ``=` `Person(``*``*``updated_values)``    ``obj.save()`

```

可以简写为：

```
`obj, created ``=` `Person.objects.update_or_create(``    ``first_name``=``'John'``, last_name``=``'Lennon'``, defaults``=``updated_values)`

```

**bulk_create(objs, batch_size=None)**

批量创建

```
`>>> Entry.objects.bulk_create([``...     Entry(headline``=``"Django 1.0 Released"``),``...     Entry(headline``=``"Django 1.1 Announced"``),``...     Entry(headline``=``"Breaking: Django is awesome"``)``... ])`

```

优于：

```
`Entry.objects.create（headline``=``"Python 1.0 Released"``）``Entry.objects.create（headline``=``"Python 1.1 Planned"``）`

```

**count()**

返回数据库中匹配查询(QuerySet)的对象数量。 count() 不会抛出任何异常。

例如：

```
`# Returns the total number of entries in the database.``Entry.objects.count()` `# Returns the number of entries whose headline contains 'Lennon'``Entry.objects.``filter``(headline__contains``=``'Lennon'``).count()`

```

count() 会在后端执行 SELECT COUNT(*) 操作，所以你应该尽量使用 count() 而不是对返回的查询结果使用 len() 。

根据你所使用的数据库(例如 PostgreSQL 和 MySQL)，count() 可能会返回长整型，而不是普通的 Python 整数。这确实是一个很古怪的举措，没有什么实际意义。

**in_bulk(id_list)**

接收一个主键值列表，然后根据每个主键值所其对应的对象，返回一个主键值与对象的映射字典。

```
`>>> Blog.objects.in_bulk([``1``])``{``1``: <Blog: Beatles Blog>}``>>> Blog.objects.in_bulk([``1``, ``2``])``{``1``: <Blog: Beatles Blog>, ``2``: <Blog: Cheddar Talk>}``>>> Blog.objects.in_bulk([])``{}`

```

如果你给 in_bulk() 传递的是一个空列表明，得到就是一个空字典。

**iterator()**

运行查询(QuerySet)，然后根据结果返回一个 迭代器(iterator。 做为比较，使用 QuerySet 时，从数据库中读取所有记录后，一次性将所有记录实例化为对应的对象；而 iterator() 则是读取记录后，是分多次对数据实例化，用到哪个对象才实例化哪个对象。相对于一次性返回很多对象的 QuerySet，使用迭代器不仅效率更高，而且更节省内存。

要注意的是，如果将 iterator() 作用于 QuerySet，那就意味着会再一次运行查询，就是说会运行两次查询。

**latest(field_name=None)**

根据时间字段 field_name 得到最新的对象。

下面这个例子根据 pub_date 字段得到数据表中最新的 Entry 对象：

```
`Entry.objects.latest(``'pub_date'``)`

```

如果你在 model 中 Meta 定义了 get_latest_by 项, 那么你可以略去 field_name 参数。Django 会将 get_latest_by 做为默认设置。

和 get(), latest() 一样，如果根据所给条件没有找到匹配的对象，就会抛出 DoesNotExist 异常。

注意 latest()和earliest() 是纯粹为了易用易读而存在的方法。

**earliest(field_name=None)**

类似于latest()

**first()**

```
`p ``=` `Article.objects.order_by(``'title'``, ``'pub_date'``).first()`

```

相当于：

```
`try``:``    ``p ``=` `Article.objects.order_by(``'title'``, ``'pub_date'``)[``0``]``except` `IndexError:``    ``p ``=` `None`

```

**last()**

类似于first()

**aggregate(\*args, **kwargs)**

通过对 QuerySet 进行计算，返回一个聚合值的字典。 aggregate() 中每个参数都指定一个包含在字典中的返回值。

聚合使用关键字参数做为注解的名称。每个参数都有一个为其订做的名称，这个名称取决于聚合函式的函数名和聚合字段的名称。

例如，你正在处理博文，你想知道博客中一共有多少篇博文：

```
`>>> ``from` `django.db.models ``import` `Count``>>> q ``=` `Blog.objects.aggregate(Count(``'entry'``))``{``'entry__count'``: ``16``}`

```

通过在 aggregate 指定关键字参数，你可以控制返回的聚合名称：

```
`>>> q ``=` `Blog.objects.aggregate(number_of_entries``=``Count(``'entry'``))``{``'number_of_entries'``: ``16``}`

```

**exists()**

如果 QuerySet 包含有数据，就返回 True 否则就返回 False。这可能是最快最简单的查询方法了.

**update()**

更新

```
`>>> Entry.objects.``filter``(pub_date__year``=``2010``).update(comments_on``=``False``, headline``=``'This is old'``)`

```

delete()

删除

```
`>>> b ``=` `Blog.objects.get(pk``=``1``)` `# Delete all the entries belonging to this Blog.``>>> Entry.objects.``filter``(blog``=``b).delete()`

```

### 字段筛选条件(Field lookups)

字段筛选条件决定了你如何构造 SQL 语句中的 WHERE 从句。它们被指定为 QuerySet 中 filter()，exclude() 和 get() 方法的关键字参数。

**exact**

精确匹配。如果指定的值是 None，就会翻译成 SQL 中的 NULL (详情请查看 isnull )。

例如：

```
`Entry.objects.get(id__exact``=``14``)``Entry.objects.get(id__exact``=``None``)`

```

等价的 SQL：

```
`SELECT ... WHERE ``id` `=` `14``;``SELECT ... WHERE ``id` `IS NULL;`

```

**iexact**

忽略大小写的匹配。

例如：

```
`Blog.objects.get(name__iexact``=``'beatles blog'``)``Blog.objects.get(name__iexact``=``None``)`

```

等价于如下 SQL ：

```
`SELECT ... WHERE name ILIKE ``'beatles blog'``;``SELECT ... WHERE name IS NULL;`

```

SQLite 用户要注意

在使用 SQLite 作为数据库，并且应用 Unicode (non-ASCII) 字符串时，请先查看 database note 中关于字符串比对那一节内容。SQLite 对 Unicode 字符串，无法做忽略大小写的匹配。

**contains**

大小写敏感的包含匹配。

例如：

```
`Entry.objects.get(headline__contains``=``'Lennon'``)`

```

等价于 SQL ：

```
`SELECT ... WHERE headline LIKE ``'%Lennon%'``;`

```

要注意，上述语句将匹配大标题 'Today Lennon honored' ，但不能匹配 'today lennon honored'。

SQLite 不支持大小写敏感的 LIKE 语句；所以对 SQLite 使用 contains 时就和使用 icontains 一样。

**icontains**

忽略大小写的包含匹配。

例如：

```
`Entry.objects.get(headline__icontains``=``'Lennon'``)`

```

等价于 SQL：

```
`SELECT ... WHERE headline ILIKE ``'%Lennon%'``;`

```

SQLite 用户请注意

使用 SQLite 数据库并应用 Unicode (non-ASCII) 字符串时，请先查看 database note 文档中关于字符串比对那一节内容。

**in**

是否在一个给定的列表中。

例如：

```
`Entry.objects.``filter``(id__in``=``[``1``, ``3``, ``4``])`

```

等价于 SQL：

```
`SELECT ... WHERE ``id` `IN (``1``, ``3``, ``4``);`

```

你也可以把查询(queryset)结果当做动态的列表，从而代替固定的列表：

```
`inner_qs ``=` `Blog.objects.``filter``(name__contains``=``'Cheddar'``)``entries ``=` `Entry.objects.``filter``(blog__in``=``inner_qs)`

```

做动态列表的 queryset 运行时就会被做为一个子查询：

```
`SELECT ... WHERE blog.``id` `IN (SELECT ``id` `FROM ... WHERE NAME LIKE ``'%Cheddar%'``)`

```

如果你传递了一个 ValuesQuerySet 或 ValuesListQuerySet (它们是调用查询集上 values() 和 values_list() 方法的返回结果) 做为 __in 条件的值，那么你要确认只匹配返回结果中的一个字段。例如，下面的代码能正常的工作(对博客名称进行过滤)：

```
`inner_qs ``=` `Blog.objects.``filter``(name__contains``=``'Ch'``).values(``'name'``)``entries ``=` `Entry.objects.``filter``(blog__name__in``=``inner_qs)`

```

下面的代码却会抛出异常，原因是内部的查询会尝试匹配两个字段值，但只有一个是有用的：

```
`# Bad code! Will raise a TypeError.``inner_qs ``=` `Blog.objects.``filter``(name__contains``=``'Ch'``).values(``'name'``, ``'id'``)``entries ``=` `Entry.objects.``filter``(blog__name__in``=``inner_qs)`

```

**warning**

query 属性本是一个不公开的内部属性，虽然他在上面的代码中工作得很好，但是它的API很可能会在不同的 Django 版本中经常变动。

性能考虑

要谨慎使用嵌套查询，并且要对你所采用的数据库性能有所了解(如果不了解，就去做一下性能测试)。有些数据库，比如著名的MySQL，就不能很好地优化嵌套查询。所以在上面的案例中，先在第一个查询中提取值列表，然后再将其传递给第二个查询，会对性能有较高的提升。说白了，就是用两个高效的查询替换掉一个低效的查询：

```
`values ``=` `Blog.objects.``filter``(``        ``name__contains``=``'Cheddar'``).values_list(``'pk'``, flat``=``True``)``entries ``=` `Entry.objects.``filter``(blog__in``=``list``(values))`

```

**gt**

大于。

**gte**

大于等于。

**lt**

小于。

**lte**

小于等于。

**startswith**

大小写敏感的以....开头。

**istartswith**

忽略大小写的以....开头。

**endswith**

大小写敏感的以....结尾。

**iendswith**

忽略大小写的以....结尾。

**range**

包含的范围。

例如：

```
`import` `datetime``start_date ``=` `datetime.date(``2005``, ``1``, ``1``)``end_date ``=` `datetime.date(``2005``, ``3``, ``31``)``Entry.objects.``filter``(pub_date__range``=``(start_date, end_date))`

```

等价于 SQL：

```
`SELECT ... WHERE pub_date BETWEEN ``'2005-01-01'` `and` `'2005-03-31'``;`

```

你可以把 range 当成 SQL 中的 BETWEEN 来用，比如日期，数字，甚至是字符。

**year**

对日期／时间字段精确匹配年分，年分用四位数字表示。

例如：

```
`Entry.objects.``filter``(pub_date__year``=``2005``)`

```

等价于 SQL：

```
`SELECT ... WHERE EXTRACT(``'year'` `FROM pub_date) ``=` `'2005'``;`

```

(不同的数据库引擎中，翻译得到的 SQL 也不尽相同。)

**month**

对日期／时间字段精确匹配月分，用整数表示月分，比如 1 表示一月，12 表示十二月。

**day**

对日期／时间字段精确匹配日期。

要注意的是，这个匹配只会得到所有 pub_date 字段内容是表示 某月的第三天 的记录，如一月三号，六月三号。而十月二十三号就不在此列。

**week_day**

对日期／时间字段匹配星期几

例如：

```
`Entry.objects.``filter``(pub_date__week_day``=``2``)`

```

等价于 SQL：

```
`SELECT ... WHERE EXTRACT(``'dow'` `FROM pub_date) ``=` `'2'``;`

```

(不同的数据库引擎中，翻译得到的 SQL 也不尽相同。)

要注意的是，这段代码将得到 pub_date 字段是星期一的所有记录 (西方习惯于将星期一看做一周的第二天)，与它的年月信息无关。星期以星期天做为第一天，以星期六做为最后一天。

**hour**

**minute**

**second**

**isnull**

根据 SQL 查询是空 IS NULL 还是非空 IS NOT NULL，返回相应的 True 或 False。

例如：

```
`Entry.objects.``filter``(pub_date__isnull``=``True``)`

```

等价于 SQL：

```
`SELECT ... WHERE pub_date IS NULL;`

```

**search**

利用全文索引做全文搜索。它与 contains 相似，但使用全文索引做搜索会更快一些。

例如：

```
`Entry.objects.``filter``(headline__search``=``"+Django -jazz Python"``)`

```

等价于：

```
`SELECT ... WHERE MATCH(tablename, headline) AGAINST (``+``Django ``-``jazz Python IN BOOLEAN MODE);`

```

要注意这个方法仅适用于 MySQL ，并且要求设置全文索引。默认情况下 Django 使用 BOOLEAN MODE 模式。详见 Please check MySQL documentation for additional details.

**regex**

大小写敏感的正则表达式匹配。

它要求数据库支持正则表达式语法，而 SQLite 却没有内建正则表达式支持，因此 SQLite 的这个特性是由一个名为 REGEXP 的 Python 方法实现的，所以要用到 Python 的正则库 re.

例如：

```
`Entry.objects.get(title__regex``=``r``'^(An?|The) +'``)`

```

等价于 SQL：

```
`SELECT ... WHERE title REGEXP BINARY ``'^(An?|The) +'``; ``-``-` `MySQL` `SELECT ... WHERE REGEXP_LIKE(title, ``'^(an?|the) +'``, ``'c'``); ``-``-` `Oracle` `SELECT ... WHERE title ~ ``'^(An?|The) +'``; ``-``-` `PostgreSQL` `SELECT ... WHERE title REGEXP ``'^(An?|The) +'``; ``-``-` `SQLite`

```

建议使用原生字符串 (例如，用 r'foo' 替换 'foo') 做为正则表达式。

**iregex**

忽略大小写的正则表达式匹配。

### 聚合函式(Aggregation Functions)

**Avg**

返回所给字段的平均值。

默认别名：<field>__avg
返回类型： float
**Count**

根据所给的关联字段返回被关联 model 的数量。

默认别名： <field>__count
返回类型： int
它有一个可选参数：

distinct
如果 distinct=True，那么只返回不重复的实例数量，相当于 SQL 中的 COUNT(DISTINCT field)。默认值是 False。
**Max**

默认别名： <field>__max
返回类型： 与所给字段值相同
**Min**

返回所给字段的最小值。

默认别名： <field>__min
返回类型： 与所给字段相同
**StdDev**

返回所给字段值的标准差。

默认别名： <field>__stddev
返回类型： float
它有一个可选参数：

sample
默认情况下， StdDev 返回一个总体偏差值，但是如果 sample=True，则返回一个样本偏差值。
SQLite

SQLite 本身并不提供 StdDev 支持，可以使用 SQLite 的外置模块实现这个功能。详情请查看相应的 SQLite 文档，了解如何获得和安装扩展。

**Sum**

计算所给字段值的总和

默认别名： <field>__sum
返回类型： 与所给字段相同
**Variance**

返回所给字段值的标准方差。

默认别名： <field>__variance
返回类型： float
它有一个可选参数：

sample
默认情况下， Variance 返回的是总体方差；如果 sample=True，返回的则是样式方差。
