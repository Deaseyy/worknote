#### 7.缓存雪崩，缓存击穿，缓存穿透，以及它们的解决方案

**7.1 缓存雪崩**

```markdown
# 概念
设置缓存时采用了相同的过期时间，导致大量缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。

# 解决方案
给缓存设置随机过期时间，我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每个缓存的过期时间的重复率就会降低，很难引发集体失效事件。
```

**7.2 缓存击穿**

```markdown
# 概念
单个key高热数据过期的瞬间，恰好数据访问量较大，未命中redis，发起大量对同一数据的请求到数据库。

# 解决方案：
可以使用锁来进行并发控制，如redis的setnx命令实现分布式锁。当一个请求检测到缓存失效时，先使用setnx获取锁，如果能成功获取(返回值为1)，则请求数据库，然后写入缓存，否则重新进行整个请求读取缓存的过程。

```

**7.3 缓存穿透**

```markdown
# 概念：
查询了一定不存在的数据，跳过了合法数据的redis数据缓存阶段，导致每次请求这个不存在的数据都要访问数据库。

# 解决方案：
最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
```



#### 8.如何保证缓存与数据库的双写一致性

**先更新数据库再删除缓存：最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。**

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。

**为什么是删除缓存，而不是更新缓存？**

```
某些缓存是经过大量计算后的结果，如果每次修改数据后都去更新缓存，那么当写操作很多，但却很少读取时，就会出

现大量冷数据。比如每分钟更新数据库100次，则需要更新100次缓存，但实际只读取了一次或很少次，那么就有很多

次的缓存更新都是没有使用到的，浪费大量计算资源。

```

所以很少采用更新缓存的做法，一般都是先删除缓存，用到时再去数据库取来计算再写入缓存。

**a.简单的缓存不一致问题及解决方案**

```markdown
# 问题分析：
先修改数据库，再删除缓存。若删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。

# 解决思路：
解决思路：**先删除缓存，再修改数据库**。若数据库修改失败，那么数据库中是旧数据，缓存中是空的，那么不会出现数据不一致问题。因为再读的时候没有缓存，则读数据库中旧数据，然后更新到缓存中。
```

**b.高并发下的缓存不一致问题分析**

```markdown
# 问题分析：
数据发生了变更，先删除了缓存，然后要去修改数据库。此时还没来得及修改，另一个请求过来，去读缓存，发现缓存

空了，去查询数据库，此时查到的是即将被修改的旧数据，放到了缓存中。随后上一个请求完成了数据库的修改。这

时，数据库和缓存中的数据不一样了。

# 解决思路：
方案1: 利用队列将读和写请求中间的部分操作异步串行化执行
- 写操作：删除缓存 --> 修改数据库
- 读操作：读缓存(若为空) --> 读数据库 --> 更新缓存
需要串行执行： 修改数据库--> 读数据库 --> 更新缓存

方案2：双删加超时，在写库前后都进行删缓存redis.del(key)操作，并且设定合理的超时时间。这样最差的情况是在超时时间内存在不一致，当然这种情况极其少见(*即同时出现并发问题和写库后删缓存失败的情况*)，可能的原因就是服务宕机。此种情况可以满足绝大多数需求。
- a、先淘汰缓存，更新数据库
- b、延时200ms
- c、再次淘汰缓存，从数据库更新最新的数据缓存
这个200ms具体该休眠多久根据自己的项目的读写数据业务逻辑的耗时而定。

方案3：使用canal解析binlog Mysql通过binlog同步redis。

```



