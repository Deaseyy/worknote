# 一，数据库设计

### 表结构

1.表中的字段和索引数量都不宜过多

2.选择innodb存储引擎

3.显示地为表创建一个使用自增列 `int` 或 `bigint` 类型作为主键，保证写入顺序自增，写入更加高效。

### 字段

**0.尽量使用较小的字段类型**

**1.金钱，日期时间，ipv4 尽量使用int来储存**

- IPV4 字段使用int存储，通过转换函数 `inet_aton` 和 `inet_ntoa`来实现
- 日期时间可以选择datetime，可用范围比timestamp大，物理存储相比后者多占一个字节，也可以使用int，通过转换函数 `from_unixtime`  和 `unix_timestamp` 来实现

**2.text 和 blob这种存储大量文字和图片的大数据类型，建议不要与业务表放在一起**

**3.像 性别sex 字段、状态status 字段，基本上选择 `tinyint` 就可以** 

**4.所有字段定义中，建议加上not null约束，避免出现null，可以使用空字符串作为默认值**

**5.很长的字符串列可以考虑创建前缀索引，提高索引利用率**

- 单表索引数量不要太多，一般建议不要超过4~5个



# 二，创建高性能索引

## 1.索引基础

索引列上存储了列的值和对应主键。

若想在一本书中找到对应主题的内容，一般先看书的索引，找到主题对应的页码，再根据页码找到标题对应的内容。MySQL也一样，先在索引中找到目标值，然后根据该值对应记录的主键回表找到对应的数据行。

**索引对如下查询有效：**

- 全值匹配
- 匹配最左前缀
- 匹配列前缀
- 匹配范围值
- 精确匹配某一列并范围匹配另外一列
- 查询只需访问索引，即覆盖索引

**B+tree索引限制：**

- 必须从索引最左列开始查找。(列也必须为从最左开始，无法查询以某个字母结尾）
- 不能跳过索引中的列，否则后面的所有列将无法使用索引查找。
- 如果查询中有某个列的范围查询( `IN`查询除外)，则其右边所有列都无法使用索引查找。

> 实用技巧：
>
> 如果范围查询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件, 或使用in查询。



## 2.索引的优点

- 减少了服务器需要扫描的数据量
- 帮助服务器避免排序和临时表
- 将随机 I/O 变为顺序 I/O



## 3.高性能索引策略

### 3.1 独立的使用列

- 索引列不能是表达式的一部分，也不能是函数的参数。否则无法使用索引。



### 3.2 索引的选择性

索引选择性：不重复的索引值 (索引列值的基数) 与 数据表的记录总数 的比值。

计算方法：select count(distinct col) / count(*) from table_name

- 索引的选择性越高则查询效率越高，它可以让MySQL在查找时过滤掉更多的行。
- 创建索引时通常会使用选择性高的列来创建索引



### 3.3 使用前缀索引

需要索引很长的字符列时，会让索引变得大且慢。可以索引开始的部分字符，节约索引空间，提高索引效率。但也会降低索引的选择性。

- 对于`BLOB`，`TEXT` 或者很长的 `VACHAR` 列，必须使用前缀索引。
- 选择足够长的前缀以保证较高的选择性，同时又不能太长（以节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列的选择性。即前缀的基数应接近完整列的基数。

> 实用技巧：
>
> 1.为了决定前缀的合适长度，可以找到最常见的值的列表，然后和最常见的前缀列表进行比较。先从较短的前缀开始比较，逐步增长，直到这个长度前缀的选择性接近于完整列的选择性。
>
> 2.另一个办法，使用上面的语句计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。

- MySQL无法使用前缀索引做 `ORDER BY` 和 `GROUP BY` ，也无法使用前缀索引做覆盖扫描。



### 3.4 多列索引

MySQL 5.0和更新版本引入了一种 “索引合并” 的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。查询能够同时使用两个单列索引进行扫描，并将结果进行合并。有三种情况：

- OR 条件的联合（多个索引做联合），通常意味着需要一个包含所有相关列的多列索引。
- AND条件的相交（多个索引做相交）
- 组合前面两种情况的联合及相交

索引合并策略有时是一种优化的结果，但实际更多时候说明了表上的索引建的很糟糕。



### 3.5 选择合适的索引列顺序

在多列B+Tree索引中，索引首先按照最左列进行排序，其次是第二列，依次下去。

一个经验法则：将选择性最高的列放在索引最前列，但通常不如避免随机 I/O 和排序那么重要。当不需要考虑排序和分组时，这个经验法则通常是很好的。

但性能不只是依赖索引列的选择性，也**和查询列的值的分布有关**。（比如一个记录用户行为的表，用户名列有一大半是系统匿名用户，当涉及这种特殊用户查询时，性能就很糟糕了）

有时也需要**根据运行频率高的查询来调整索引列的顺序**，让这种情况下索引的选择性最高。



### 3.6 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结构中保存了B+Tree索引和数据行。

- 使用InnoDB时应该尽可能按主键顺序插入插入数据，并且使用单调增加的聚簇键的值来插入新行。



### 3.7 覆盖索引

覆盖索引：一个索引包含了所有需要查询的字段的值。这种情况无需再回表查询。

如果查询只需要扫描索引而无需回表，会带来许多好处；比如索引条目通常小于数据行大小，若只需读取索引，将极大地减少数据访问量。

MySQL查询优化器会在执行查询前，判断是否有一个索引能够覆盖当前查询的列。

> 实用技巧：
>
> 某些情况下，当索引无法覆盖所有查询列时，可以使用延迟关联。延迟对列的访问，在查询的第一阶段可以使用覆盖索引，找到匹配的主键值，根据主键关联原表获取需要的所有列值。



### 3.8 使用索引扫描来做排序

MySQL有两种方式可以生成有序的结果： 1.通过排序操作；2.按索引顺序扫描。如果EXPLAIN出来的type列值为’index‘， 则说明使用了索引扫描。

**扫描索引本身是很快的，但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回表查询一次对应的行。这基本上都是随机 I/O，因此按索引顺序读取数据的速度有时会比顺序地全表扫描慢。**

假如索引扫描时，读取磁盘的次数是查询包含的记录数T，而如果全表扫描，则读取磁盘的次数是存储记录的块数B，如果T>B ，索引就没有优势了。

- 只有当索引的列顺序和order by 子句的顺序完全一致，且所有列的排序方向一致，才能够使用索引来对结果做排序



### 3.9 冗余和重复索引

重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应避免这样创建重复索引。（不同类型索引：指数据结构不同）

- 如果创建了索引 (A,B) , 再创建索引 (A) 就是冗余索引；如果再创建索引 (B,A) 或 (B) 则不是冗余索引。

- 对于InnoDB来说，二级索引包含了主键列；如果创建了索引 (A) , 则（A, ID）也是冗余索引。

  再如索引 (A, B)，实际就是 (A, B, ID)

- 大多数情况下，应该尽量扩展已有的索引而不是创建新索引。

- 也有时出于性能考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，影响其他使用该索引的查询的性能。例如，在整数列上有一个索引，现需要增加一个很长的VARCHAR列来扩展该索引，那些使用这个整数索引列的查询性能可能会急剧下降。



### 3.10 索引和锁

索引可以让查询锁定更少的行。InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。

但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效行，那么在InnoDB检索到数据并返回给服务器层以后，MySQL服务器才能应用where子句，这时已经无法避免锁定行了：InnoDB已经锁定了这些行，到适当的时候才释放。

- Extra列出现“Using where”， 表示MySQL服务器将在存储引擎返回行以后再应用where过滤条件。
- 即使使用了索引，InnoDB也可能锁住一些不需要的行
- 如果不能使用索引查找和锁定行的话，MySQL会做全表扫描并锁住所有的行。
- InnoDB 在二级索引上使用共享锁，但访问主键索引需要排他锁。



## 4.索引案例学习

设计一个在线约会网站，用户信息表包括国家，地区，城市，性别，眼睛颜色等等。

现在需要看哪些列选择性高，哪些列在where子句中使用得最频繁。

国家country 列的选择性通常不高，但可能很多查询都会用到；性别sex 列的选择性低，但几乎所有查询都会用到。考虑到使用的频率，建议在创建不同组合索引的时候将 (sex, country) 列作为前缀。年龄age 通常会使用范围查找，而查询只能使用索引的最左前缀，直到遇到第一个范围条件列，所以应该放在索引的最右侧 (sex, country, age)。

- 尽可能将需要做范围查询的列放到多列索引的后面，以便优化器能使用尽可能多的索引列。
- 在索引使用上，in查询不同于其他范围查询，它不会导致后面的其他索引列无法使用。

更重要的一点是，索引中加上 sex 这一列也没有坏处，即使查询没有使用sex列也可以通过下面的技巧绕过：

> 技巧：
>
> 如果可以，将范围查询转化为 IN 查询，来避免多列索引时因范围查询导致后面的索引列无法使用。
>
> 对于索引(sex, country), 如果某个查询不限制性别，又想要使用这个索引，那么可以通过在查询条件中新增AND sex IN('m'，'f') 来让mysql选择该索引。部分场景这种技巧很有效，但如果列有太多不同的值，in列表太长就不行了。



## 5.维护索引和表

### 5.1 修复损坏的表

通过一个不作任何操作的alter操作来重建表，对于InnoDB引擎，通过修改表的存储引擎为当前的引擎来重建表：

```
ALTER TABLE innodb_tbl ENGINE=INNODB
```



### 5.2 更新索引统计信息

MySQL优化器会通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。

- 第一个API是 `records_in_range()` , 通过向存储引擎传入两个边界值获取在这个范围大概有多少条记录。对于某些存储引擎，该接口返回精确值，例如MyISAM；但对于InnoDB则是返回一个估算值。
- 第二个API是 `info()` , 该接口返回各种类型的数据，包括索引的基数。

如果表没有统计信息，或者统计信息不正确，优化器可能做出错误的决定，通过运行 `ANALYZE TABLE` 来重新生成统计信息解决这个问题。



### 5.3 减少索引和数据的碎片

如下方法：

- 通过执行 `OPTIMIZE TABLE` 或者导出再导入的方式来重新整理数据
- 通过先删除索引，再重新创建索引的方式来消除索引的碎片化
- 对于不支持`OPTIMIZE TABLE`的存储引擎，可以使用上面优化损坏表同样的操作，将表的存储引擎修改为当前存储引擎



# 三，优化查询

## 1.优化数据访问

**1.不要检索大量非需要的数据，通常意味着访问了太多的行或列**

- 尽量避免使用select *。（除了需要缓存所有列的查询）

**2.确认MySQL服务器层是否在分析大量超过需要的数据行，使用EXPLAIN语句。**

- 为了返回结果，是否扫描了额外的记录（分析返回行数，扫描行数）
- 根据type列的访问类型优化，从慢到块：全表扫描，索引扫描，范围扫描，唯一索引查询，常熟引用。

> **相关优化技巧：**
>
> 如果发现查询需要扫描大量的数据但只返回少数的行，尝试如下：
>
> a.使用索引覆盖扫描，把所有需要用的列都放到索引中，可以直接返回结果无需回表获取对应行.
>
> b.改变库表结构。例如使用单独的汇总表.
>
> c.重写这个复杂查询，让MySQL优化器能够以更优的方式执行它.

**3.避免重复查询相同的数据**

- 例如，用户评论需要获取用户头像，那么多次评论时，可能会反复查询这个数据。



## 2.重构查询方式

一个复杂查询还是多个简单查询。MySQL内部每秒能够扫描内存中上百万行数据，相比之下，MySQL响应数据给客户端就慢得多。**使用尽可能少的查询是更好的**，但有时候也需要将一个大查询分解为多个小查询。

**1.切分查询**

- 将一个大的delete语句切分成多个小的查询可以尽可能小地影响MySQL性能，同时还能减少Mysql复制的延迟。例如，定期清除大量旧数据，一次性完成可能需要锁住很多数据，占满事务日志。

**2.分解关联查询**

- 对每一张表进行一次单表查询，然后在应用层关联；优势如下：
  - 让缓存的效率更高
  - 执行单个查询可减少锁的竞争
  - 应用层做关联，更容易对数据库进行拆分
  - 减少冗余记录的查询。数据库关联可能需要重复访问一部分数据



## 3.优化特定类型查询

### 1. 排序优化

当不能使用索引生成排序结果的时候，MySQL需要自己排序，数据量小则在内存中进行，数据量大则需要使用磁盘，这两种统称为文件排序。

- 尽可能避免排序或者避免对大量数据进行排序



### 2. IN 加子查询

- 查询带有相关子查询时，比如使用 `exists` 语句，外层的表不宜过大，否则查询性能非常糟糕。可以使用关联查询重写。
- 一般in子查询的优化方式：
  - 可使用关联查询重写
  - 另一个办法，使用函数 `GROUP_CONCAT()` 在 `in()` 中构造一个由逗号分隔的列表。有时比使用关联查询更快。



### 3. 最大值和最小值优化

```mysql
-- 案例：
select min(actor_id) from sakila.actor where first_name='PENELOPE';
-- 因为first_name字段上没有索引，将进行一次全表扫描；如果MySQL能进行主键扫描，那么读到第一个满足条件的记录时，就是我们要的最小值了。

-- 一个曲线的优化办法是移除min(),使用limit来将查询重写：
select actor_id from sakila.actor use index(primary) where first_name='PENELOPE' limit 1;
-- 这个策略可以让MySQL扫描尽可能少的记录数。
```



### 4. 优化count查询

- **使用近似值。**某些业务场景并不要求完全精确的count()值，此时可以用近似值来替代。EXPLAIN 出来的优化器估算的行数就是一个不错的近似值。EXPLAIN不需要真正执行，成本很低。
- **增加汇总表**



### 5. 优化关联查询

- **确保on子句中的列上有索引。**除非有其他理由，否则只需要在关联顺序中的第二个表的相应列上创建索引；注意是优化器优化过的关联顺序(参考执行计划)。



### 6. 优化 group by

**MySQL中，当无法使用索引时，group by 使用两种策略完成：使用临时表或者文件排序来做分组。**

- **使用查找表的标识列分组**

  举例，如果要对关联查询做分组，并且是按照查找表中的某个列进行分组，那么通常采用查找表的标识列分组的效率会更高。如下查询效率不会很好：

  ```mysql
  select actor.first_name,actor.last_name,count(*) from film_actor inner join actor on film_actor.actor_id=actor.actor_id group by actor.first_name,actor.last_name;
  ```

  改写为如下效率更高：

  ```mysql
  select actor.first_name,actor.last_name,count(*) from film_actor inner join actor on film_actor.actor_id=actor.actor_id group by film_actor.actor_id;
  -- 使用actor.actor_id列分组的效率甚至会更好，简单测试即可验证
  ```

  这个查询利用了演员姓名和ID直接相关的特点，因此改写后的结果不受影响。

- **控制分组时的排序，尽量避免文件排序**

  如果没有通过 `order by` 子句显式地指定排序列，当查询使用 `group by` 子句时，结果集会自动按照分组的字段进行排序。如果不关心结果集的顺序，而这种默认排序又导致了文件排序，则可以使用 `order by null`，让MySQL不再进行文件排序。也可以在 `group by` 子句中直接使用 DESC 或 ASC 关键字，使分组的结果集按需要的方向排序。



### 7. 优化 limit 分页

当偏移量非常大时，查询的效率将会很差。它会导致MySQL扫描前面大量的行，最终取指定条记录，其他记录都将被丢弃。优化参考方式包括：**1.限制分页数量  2. 优化大偏移量的性能  3.避免使用offset。**

具体优化案例参考：

- **尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。**

  例如下面的查询：

  ```mysql
  select film_id,description from film order by title limit 50,5;
  ```

  如果这个表非常大，最好改写为如下：

  ```mysql
  select film.film_id, film.description from film inner join (select film_id from film order by title limit 50,5) as lim on film.film_id=lim.film_id
  ```

  这种延迟关联将大大提升查询效率，它让MySQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列回原表查询需要的所有列。

- **记录上次取数据的位置，下次直接从已记录的位置开始扫描，避免使用offset。也就是将 limit 查询转换为已知位置的查询，让MySQL通过范围扫描获得到对应的结果。**

  例如，若在一个列上有索引，并且预先计算出了边界值，上面的查询可以改写为：

  ```mysql
  select film_id, description from film where position between 50 and 54 order by position;
  ```

  再如某些场景下，只允许上下翻页，根据边界记录的id(当前页的最大或最小id)直接定位到上一页或下一页。



### 8. 优化 distinct 

- 尝试删除 distinct 这样的约束来避免文件排序。



# 四，优化总结

### 1.查询优化

1.使用 or查询 导致联合索引失效时，如：

```
# 已建立联合索引（c1,c2）
select * from t where c1=1 or c2=2 # 无法使用到索引
```

优化：尽量避免在sql语句中出现or查询；可以分别建立单独索引，使用union查询

2.使用联合索引，必须满足最左前缀原则

3.尽量只取需要的列，不使用select *，减少网络宽带，还有可能利用到覆盖索引

4.避免使用union，尽量采用union all，减少数据库去重和排序工作，交给应用程序。



### 2.索引无法使用的情况

1.通过索引扫描的行记录数超过全表的 30%，优化器就不会走索引，而变成全表扫描。

2.使用联合索引时，查询条件没有包含最左索引列。(如果想使用到更多索引列，则必须满足最左前缀原则，多个条件最好按索引列顺序摆放)

3.使用联合索引时，第一个查询条件不是最左前缀列。（必须是最左索引列，且最左前缀列，不能只取列的后面部份，如 right(name, 2) ）

4.使用联合索引时，如果前面的索引列使用了范围查询，则后面的列无法使用索引，即只用到部分索引。（范围查询指 <, >, <=, >=, between and)

5.模糊查询条件列最左以通配符 % 开始。（即 没有索引到最左前缀，可以考虑放到子查询）

6.两个单列索引，一个用于检索，一个用于排序。这种情况下只能使用到一个索引，因为查询语句中最多只能使用一个索引，考虑建立联合索引。（两个建了单列索引的列等值查询时，会出现Using intersect(a,b); ）

7.字段建了索引，但使用了函数运算。



# 五，知识点

### 1.列表in()的比较：

在很多数据库系统中，in() 完全等同于多个OR条件的子句，但MySQL不是；(O(n)复杂度)

MySQL将in列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件。(O(logn)复杂度)



### 2.MySQL关联执行的策略

**MySQL对任何关联都执行嵌套循环关联操作**，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，知道找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中的列。

MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，将返回到上一层次关联表，看是否能够找到更多的匹配记录，以此类推迭代执行。

**MySQL总是从一个表开始一直嵌套循环、回溯完成所有关联表。**



### 3.返回结果给客户端

MySQL将结果集返回客户端是一个增量，逐步返回的过程。

拿关联查询来说，一旦服务器处理完最后一张关联表，开始生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。

两个好处：1.服务端无需存储太多的结果，也就无需消耗太多内存；2.让客户端第一时间获得返回的结果



### 4.索引合并优化

当where子句中包含多个复杂条件时，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。



# 操作

1.对某个查询执行 EXPLAIN EXTENDED 后，再执行 SHOW WARNINGS，就可以看到优化器重构出的查询。
