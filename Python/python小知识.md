### 1, python的类变量和成员变量

**通过self.的方式调用变量时，默认会先获取本类中的成员变量，当该成员变量名不存在时，再去调用类变量，*<u>会将类变量进行拷贝，不改变类变量的原有值</u>*。**

python的类变量和C++的静态变量不同，区别在于python的对象使用类变量时，会进行一次内存拷贝。python中，类本身拥有自己的类变量（保存在内存），当对象第一次调用类变量时，会将当前类变量拷贝一份给这个对象，当前类变量的值是多少，这个对象拷贝得到的类变量的值就是多少；而且，通过对象来修改类变量，并不会影响其他对象的类变量的值，因为大家都有各自的副本，更不会影响类本身所拥有的那个类变量的值；**只有类自己才能改变类本身拥有的类变量的值。**



### 2, 两个list使用 + 号或使用extend合并

- +号会新生成一个空列表，再将两个列表的元素拷贝进去
- extend 是将指定list的元素追加到原list中

**注意：`+=`符号有所不同；如：list_a += list_b，原地追加，将list_b的元素追加到list_a，类似extend操作。**



### 3，序列的增量赋值

增量赋值运算符 `+=` 和 `*=` 的表现取决于它们的第一个操作对象，`+=` 背后的特殊方法是 `__iadd__ `（用于“**就地加法**”）。但是**如果一个类没有实现 `__iadd__ `这个方法的话，Python 会退一步调用 `__add__`。**

对于 `a += b`， 如果 a 实现了 `__iadd__` 方法，就会调用这个方法。同时对可变序列（例如list、bytearray 和 array.array）来说，a 会就地改动，就像调用了 a.extend(b)一样。但是如果 a 没有实现` __iadd__ `的话，a += b 这个表达式的效果就变得跟 `a = a + b` 一样了。

总体来讲，可变序列一般都实现了 `__iadd__` 方法，因此 `+=` 是就地加法。而不可变序列根本就不支持这个操作，对这个方法的实现也就无从谈起。上面所说的这些关于 += 的概念也适用于 *=，不同的是，后者相对应的是 `__imul__`。



举例：当a为列表时：`a += b` 和 `a = a + b` 的区别

如 ：a = [1, 2, 3] , b = 'abc'，变量 b 必须要为可迭代类型

- 执行 a += b，最终a的结果为 [1, 2, 3, 'a', 'b', 'c']。
- 执行 a = a + b，会报错 `TypeError: can only concatenate list (not "str") to list`



对不可变序列进行重复拼接操作的话，效率会很低，因为每次都有一个新对象，而解释器需要把原来对象中的元素先复制到新的对象里，然后再追加新的元素。



### 4，列表的切片赋值

如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单
独一个值，也要把它转换成可迭代的序列。

```python
arr = [1,2,3,4,5,6,7,8,9,10,11,12,13]
# 会将右边的可迭代对象拆分为单独元素，然后替换切片区域元素
arr[2:3] = ['q','w','e'] # [1, 2, 'q', 'w', 'e', 5, 6, 7, 8, 9, 10, 11, 12, 13]
arr[2:10] = ['q'] # [1, 2, 'q', 11, 12, 13]
arr[2:10] = 'q'   # 字符串也是可迭代对象，[1, 2, 'q', 11, 12, 13]
arr[2:10] = 'qwe' # [1, 2, 'q', 'w', 'e', 11, 12, 13]
arr[2:10] = 100   # 报错：TypeError: can only assign an iterable
del arr[2:10]     # [1, 2, 11, 12, 13]
```


### 5. 对序列使用 `+` 和 `*`

通常 `+` 号两侧的序列由相同类型的数据所构成，在拼接的过程中，两个被操作的序列都不会被修改，Python 会新建一个包含同样类型数据的序列来作为拼接的结果。

如果想要把一个序列复制几份然后再拼接起来，更快捷的做法是把这个序列乘以一个整数。

`+ `和 `* `都遵循这个规律，不修改原有的操作对象，而是构建一个全新的序列。






