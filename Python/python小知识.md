### 1, python的类变量和成员变量

**通过self.的方式调用变量时，默认会先获取本类中的成员变量，当该成员变量名不存在时，再去调用类变量，*<u>会将类变量进行拷贝，不改变类变量的原有值</u>*。**

python的类变量和C++的静态变量不同，区别在于python的对象使用类变量时，会进行一次内存拷贝。python中，类本身拥有自己的类变量（保存在内存），当对象第一次调用类变量时，会将当前类变量拷贝一份给这个对象，当前类变量的值是多少，这个对象拷贝得到的类变量的值就是多少；而且，通过对象来修改类变量，并不会影响其他对象的类变量的值，因为大家都有各自的副本，更不会影响类本身所拥有的那个类变量的值；**只有类自己才能改变类本身拥有的类变量的值。**



### 2, 两个list使用 + 号或使用extend合并

- +号会新生成一个空列表，再将两个列表的元素拷贝进去
- extend 是将指定list的元素追加到原list中

**注意：`+=`符号有所不同；如：list_a += list_b，原地追加，将list_b的元素追加到list_a，类似extend操作。**



### 3，`a += b` 和 `a = a + b` 的区别

`+=` 会将其后面的数据类型转换成和左边变量一致的类型再进行相加操作。

如 ：a = [1, 2, 3] , b = 'abc'

- 执行 a += b，会先将b转化为为列表, list('abc')，最终a的结果为 [1, 2, 3, 'a', 'b', 'c']。
- 执行 a = a + b，会报错 `TypeError: can only concatenate list (not "str") to list`



### 4，列表的切片赋值

如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单
独一个值，也要把它转换成可迭代的序列。

```python
arr = [1,2,3,4,5,6,7,8,9,10,11,12,13]
# 会将右边的可迭代对象拆分为单独元素，然后替换切片区域元素
arr[2:3] = ['q','w','e'] # [1, 2, 'q', 'w', 'e', 5, 6, 7, 8, 9, 10, 11, 12, 13]
arr[2:10] = ['q'] # [1, 2, 'q', 11, 12, 13]
arr[2:10] = 'q'   # 字符串也是可迭代对象，[1, 2, 'q', 11, 12, 13]
arr[2:10] = 'qwe' # [1, 2, 'q', 'w', 'e', 11, 12, 13]
del arr[2:10]     # [1, 2, 11, 12, 13]
```







