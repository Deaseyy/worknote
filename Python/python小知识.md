### 1, python的类变量和成员变量

**通过self.的方式调用变量时，默认会先获取本类中的成员变量，当该成员变量名不存在时，再去调用类变量，*<u>会将类变量进行拷贝，不改变类变量的原有值</u>*。**

python的类变量和C++的静态变量不同，区别在于python的对象使用类变量时，会进行一次内存拷贝。python中，类本身拥有自己的类变量（保存在内存），当对象第一次调用类变量时，会将当前类变量拷贝一份给这个对象，当前类变量的值是多少，这个对象拷贝得到的类变量的值就是多少；而且，通过对象来修改类变量，并不会影响其他对象的类变量的值，因为大家都有各自的副本，更不会影响类本身所拥有的那个类变量的值；**只有类自己才能改变类本身拥有的类变量的值。**



### 2, 两个list使用 + 号或使用extend合并

- +号会新生成一个空列表，再将两个列表的元素拷贝进去
- extend 是将指定list的元素追加到原list中

**注意：`+=`符号有所不同；如：list_a += list_b，原地追加，将list_b的元素追加到list_a，类似extend操作。**



### 3，a为列表时：`a += b` 和 `a = a + b` 的区别

变量 b 必须要为可迭代类型，`+=` 会将其拆分为单独元素，追加到a中。

如 ：a = [1, 2, 3] , b = 'abc'

- 执行 a += b，最终a的结果为 [1, 2, 3, 'a', 'b', 'c']。
- 执行 a = a + b，会报错 `TypeError: can only concatenate list (not "str") to list`



### 4，列表的切片赋值

如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单
独一个值，也要把它转换成可迭代的序列。

```python
arr = [1,2,3,4,5,6,7,8,9,10,11,12,13]
# 会将右边的可迭代对象拆分为单独元素，然后替换切片区域元素
arr[2:3] = ['q','w','e'] # [1, 2, 'q', 'w', 'e', 5, 6, 7, 8, 9, 10, 11, 12, 13]
arr[2:10] = ['q'] # [1, 2, 'q', 11, 12, 13]
arr[2:10] = 'q'   # 字符串也是可迭代对象，[1, 2, 'q', 11, 12, 13]
arr[2:10] = 'qwe' # [1, 2, 'q', 'w', 'e', 11, 12, 13]
arr[2:10] = 100   # 报错：TypeError: can only assign an iterable
del arr[2:10]     # [1, 2, 11, 12, 13]
```







